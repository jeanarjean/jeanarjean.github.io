{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/blog/2020-11-29-code-complete-16-years-later/","result":{"data":{"site":{"siteMetadata":{"title":"jean.arjean","author":"jean.arjean"}},"markdownRemark":{"id":"7677f354-29b5-5e63-8201-10bd1a73ed3b","html":"<p>It's been 16 years since the publication of the second edition of Code Complete and 27 years since the publication of the first edition.\nConsidering this is a technical book, it is worth asking whether the book is worth a read considering its age and the evolution speed\nof software development.</p>\n<p>The book is still relevant and it turns out developping software hasn't changed <strong>that much</strong> during the last 16 years, yes the tools have evolved, but the foundations remain the same.\nThe following articles explore my favorite excerpts from Code Coplete.</p>\n<h1>The right metaphors for programming</h1>\n<p>The right metaphor for prorgramming is construction, programming is close to the act of building something. </p>\n<p><em>A small project will need less or no planning while a project with a big scope will need a lot of planning to\nminimize uncertainty and clarify requirements 'till they're TOO specified and there's nothing else that is an uncertainty.</em></p>\n<p><em>The bigger the project, the harder it is do changes to the foundation since more things will depend on it. For example, in a shed, it's easy to change a whole wall or a whole room, in a big building,\na room might have certain constraints or dependent rooms that make it much more complicated to change it.</em></p>\n<h1>Pre-Requisistes, Defects and why Software Quality matters</h1>\n<h2>Pre-Requisites</h2>\n<p>Pre-Requisistes are one of the most impactful part of software construction, yet they are very often neglected as they are not a part of software construction that programmers typically like. A software that doesn't\nrespond to what the client is expecting is no good.</p>\n<p>In order to have a greater overview of the system, it is important to always consider what's the problem the software is trying to achieve.  <em>Don't waste time solving the wrong problem.</em>\n<em>If a good problem definition hasn,t been specified, you might be solving the wrong problem during construction.</em></p>\n<p>About 20% of a software development project should be spent collecting pre-requisistes, a good sign that you have spent enough time is being able to tell yourself: </p>\n<p>Try to identify and define the essentials requirements that will have the most impact on the project.</p>\n<p>If requirements are unstable, treat requirements as its own project.</p>\n<p><em>It's as if you were a contractor called to work on a house. Your customer says, \"What will it cost to do the work?\" You reasonably ask,\n\"What do you want me to do?\" Your customer says, \"I can't tell you, but how much will it cost?\" You reasonably thank the custome for wasting your time and go home</em>.</p>\n<p><em>Attention to quality at the begining has a greater influence on product quality than attention at the end</em></p>\n<h2>Defects</h2>\n<p>The more defects you have in the software you're building, the less you time you spend on building it. The later in the construction phase a defect is detected, the costlier it is to fix it. A defect that could have\nbeen spotted in the pre-requisite phase will be the costliest to correct.</p>\n<p><em>A defect, the farther on it is detected, the more costly it is,\na defect of the planning phase detected in the implementation phase will be\nmuch more costly than if it had been detected in the planning phase.</em></p>\n<p>Hence, it is important to ask oursevles how we can minimize defects during construction, so we can spend more time on construction.</p>\n<h2>Software Quality</h2>\n<p><em>The General Principle of Software Quality is that improving quality reduces development costs. This principle is based on the fact that the best way to improve productivity to reduce the time spent reworking code.</em></p>\n<p>The single biggest activity on most project is debugging and correcting code that doesn't work properly. Debugging and associated refactoring and other rework consume about 50 percent of the time on a traditional, naive software-development cycle. Reducing debugging by preventing errors improve productivity. Therefore, the most obvious method of shortening a development schedule is to improve the quality of the product and decrease the amount of time spent debugging and reworking the software.</p>\n<p>software defect removal is actually the most expensive and time-consuming form of work for software.</p>\n<h3>Software Quality Techniques</h3>\n<p>Some software quality techniques presented in Code Complete seem to have gone out of fashion for, a useful learning to retain from Code Complete however is that no single software quality technique is sufficient\nto remove most of the defects found in the process of software development, software quality techniues are good in combination.</p>\n<p><em>The upshot is that defect detection methods work better in combination than they do singly. (... )cumulative defect-dection efficieny is significantly higher than that of any individual technique.</em></p>\n<p>Table 20-2. Defect-Detection Rates<br>\n| Removal Step |  Lowest Rate  | Modal Rate  | Highest Rate |\n| --- |  --- |  --- |  --- |\n| design reviews | 25% |  35%  |40%  |\n| Formal design inspections | 45% |  55% |  65% |\n| Informal code reviews | 20% |  25% |  35% |\n| Formal code inspections | 45% |  60% |  70% |\n| Modeling or prototyping | 35% |  65% |  80% |\n| Personal desk-checking of code | 20% |  40% |  60% |\n| Unit test | 15% |  30% |  50% |\n| New function (component) test | 20% |  30% |  35% |\n| Integration test | 25% |  35% |  40% |\n| Regression test | 15% |  25% |  30% |\n| System test | 25% |  40% |  55% |\n| Low-volume beta test (&#x3C;10 sites) | 25% |  35% |  40% |\n| High-volume beta test (>1,000 sites) | 60% |  75% |  85% |</p>\n<p>Source: Adapted from Programming Productivity (Jones 1986a), \"Software Defect-Removal Efficiency\" (Jones 1996), and \"What We Have Learned About Fighting Defects\" (Shull et al. 2002).</p>\n<h1>Software Construction</h1>\n<h2>Software Architecture</h2>\n<p><em>Architecture refers to design constraints of systemwide, whereas high-level design refers to design constraints that apply at the subsystem or multiple-class level, but not necessarily systemwide.</em></p>\n<p><em>A good architecture should fit the problem. When you look at the architecture, you should be pleased by how natural and easy the solution seems. It shouldn't look as if the problem and archietcture have been forced togheter with duct tape</em></p>\n<p><em>It should be specified what the system aims, for a system that aims for maintenability over performance will be very different than a system designed for performance.</em></p>\n<h3>Program Organization</h3>\n<p>The architecture should define the major building blocks of a program.\n<em>What each building block is responsible for should be well defined. A building block should have on area of responsibility, and it should know as little as possible about other building block's areas of responsibility. By minimizing what each building block knows about the other building blocks, you localize infromation about the design into single building blocks.</em></p>\n<p>Furthermore, the architecture should explain why the program is structured this way.\n<em>In the architecture, you should find evidence that alternatives to the final organization were considered and find the reawsons for choosing the final organization over its alternatives. It,s frustating to work on a class when it seems as if the class's role in the system has not been cleary conceived.</em></p>\n<h3>Major classes</h3>\n<p><em>The architecture should specify the major classes to be used. It should identify the responsibilities of each major class and how the class will interact with other classes.</em></p>\n<h3>Data Design:</h3>\n<p><em>The architecture should describe the major files and tables design to be used.</em>\n<em>During construction. such information gives you insight into the minds of the architects. During maintenance, the same insight is an invaluable aid. Without it, you're watching a foreign movie with no subtitles.</em> </p>\n<h3>Business Rules, business rules that impose certain constraints on the software.</h3>\n<p><em>If the architecture depends on specific business rules, it should identify them and describe the impact the rules have on the system's design.</em></p>\n<h3>User Interface Design (decoupled from the main software)</h3>\n<p><em>The user interface is often specified at requirements time. If it isn't, it should be specified in the software architecture. The architecture should specify major elements of web page formats, GUIs, command line interfaces, and so on. Careful architecture of the user interface makes the difference between a well-liked program and one that's never used</em></p>\n<h3>Resource Management (managing scarce resources (threads, database connections, etc..))</h3>\n<p><em>The architecutre should describe a plan for managing scarce resources such as database connections, threads, and handles.</em></p>\n<h3>Security</h3>\n<p><em>The architecture should describe the approach to design-level and code-level secrutiy. If a threat model has not previosuly been built, it should be built at architecture time</em></p>\n<h3>Performance</h3>\n<p><em>If performance is a cconcern, performance ghoals should be specified in the requirements.</em></p>\n<h3>Scalability</h3>\n<p><em>The architecture should address how it will addresss growth in number of users, numbers of servers, numbber of network noodes, number of database records, size of database records, transaction volume, and so on. If the system is not expected to grow and scalablity is not an issue, the architecture should make that assumption explicit.</em></p>\n<h3>Internationalization</h3>\n<p>The architecure should specify how you're going to handle internationalization.</p>\n<h3>Error Processing</h3>\n<p>Error processing guidelines should be defined at the architecture level. Here are some questions that are important to be considered.</p>\n<ul>\n<li>Is error processing corrective or merely detective.</li>\n<li>Is error detection active or passive?</li>\n<li>How does the system propagate errors?</li>\n<li>What are the convetions for handling error messages</li>\n<li>How will exception be handled? The archietcture should address when the code can throw exceptions, where they will be caught, how they will be logged, how they will be documented, and so on.</li>\n<li>Inside the program, at what level are errors handled? You can handle them at the point of detection, pass them off to an error-handling class, or pass them up the call chain.</li>\n<li>\n<p>What is the responsibility of each class for validating its input data.</p>\n<h3>Fault Tolerance</h3>\n<p><em>The architecture should also indicate the kind of fault tolerance expected. Fault tolerance is a colection of techniques that increase a system's reliability by detecting errors, recovering from them if possible, and containing their bad effects if not.</em></p>\n<h3>Architectural Feasibility</h3>\n<p><em>The architecture should demonstrate that the system is technically feasible.</em></p>\n<h3>Overengineering</h3>\n<p>You can set the engineering requirements in the architecture documentation, this way you can avoid having multiple classes of different qualities.\n<em>The architecture should indicate cleary whether programmers should err on the side of overengineering or on the side of doing the simplest thing that works</em>\n<em>A software is only as strong as the multiplications of all the weakest links.</em></p>\n<h3>Buy-vs.-build decisions</h3>\n<p><em>The most radical solution to building software is not to build it at all-to buy it instead or to download opens-ource software for free.</em>\n<em>If the architecture isn't using off-the-shelf components, it should explain the ways in which it expects custom-built components to surpass ready made libraries and components</em></p>\n<h3>Reuse decisions</h3>\n<p><em>If the plan calls for using preexisting software, test cases, data formats or other materials, the architecture should explain how the reused software will be to conform ot the other architectural goals-if it will be made to comform.</em></p>\n<h3>Change Strategy</h3>\n<p><em>The architecture shold clearly describe a strategy for handling changes. The architecture should show that possible enchancements have been considered and that the enchancements most likely are also the easiest to implement.</em></p>\n</li>\n</ul>\n<h2>Design in Construction</h2>\n<p>// TODO what is design\n<em>Regardless of how it's done, small projects benefit from careful design just as larger projects do.</em></p>\n<h3>Importance of managing complexity</h3>\n<p><em>Managing complexity is the most important technical topic in software development. In my view, it's so important that Software's Primary Technical Imperative has to be managing complexity.</em></p>\n<p>The goal is to minimize the amount of a program you have to think about at any one time.</p>\n<p>The goal of all software design techniques is to break a complicated problem into simple pieces.</p>\n<ul>\n<li>Minimize the amout of essential complexity that anoyne's brain has to deal with at any one time.</li>\n<li>Keep accidental complexity from needlessly proliferating.</li>\n</ul>\n<p><em>When I am wokring on a problem I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautfiul, I know it is wrong.</em> - R. Buckminster Fuller</p>\n<h3>Desirable Characteristics of a Design</h3>\n<p>//TODO this shit</p>\n<h4>Minimal Complexity</h4>\n<p>Make the design as easy as possible to understand.\n<em>If your design doesn't let you safely ignore most other parts of the program when you're immersed in one specific part, the design isn't doing its job.</em></p>\n<h4>Ease of Maintenance</h4>\n<p><em>Think of the maintenance programmer as your audience, and then design the system to be self-explanatory.</em></p>\n<h4>Loose Coupling</h4>\n<p><em>Loose coupling means designing so that you hold connections among different parts of a program to a minimum.</em></p>\n<h4>Extensibility</h4>\n<p><em>Extensibility means that you can enhance a system without causing violence to the underlying structure.</em></p>\n<h4>Reusability</h4>\n<p><em>Reusability means designing the system so that you can reuse pieces of it in other systems</em></p>\n<h4>High fan in</h4>\n<p><em>High fan-in refers to having a high number of classes that use a given class. High fan-in implies that a system has been designed to make good use of utility classes at the lower levels in the system.</em></p>\n<h4>Low-to-medium fan-out</h4>\n<p><em>Low-to-medium fan-out means having a given class use a low-to-medium number of other classes.</em> If a class uses too many classes, it's probably too complex.</p>\n<h4>Portability</h4>\n<p><em>Portability means designing the system so that you can easily move it to another environment.</em></p>\n<h4>Leanness</h4>\n<p><em>Leanness means designing the system so that it has no extra parts</em> <em>Voltaire said that a book is finished not when nothing more can be added but when nothing more can taken away.</em></p>\n<h4>Stratification</h4>\n<p><em>Stratification means trying to keep the levels of decomposition stratified so that you can view the system at any single level and get a consistent view. Design the system so that you can view it at one level without dipping into other levels.</em></p>\n<h4>Standard techniques</h4>\n<p><em>The more a system relies on exotic pieces the more intimidating it will be for someone trying to undestand it the frist time. Try to give the whole system a familiar feeling by using standardized, common approaches.</em></p>\n<h1>Managing Construction</h1>\n<h2>How Program Size affects Construction</h2>\n<p>The bigger the project, the more defects per lines of codes will be present, defects per line of code doesn't scale linearly, the bigger the project, the more\ndefects per line of code is present.</p>\n<table>\n<thead>\n<tr>\n<th>Project Size (in Lines of Code)</th>\n<th>Typical Error Density</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Smaller than 2K</td>\n<td> 0 25 errors per thousand lines of code (KLOC) </td>\n</tr>\n<tr>\n<td>2K 16K</td>\n<td>0 40 errors per KLOC </td>\n</tr>\n<tr>\n<td>16K 64K</td>\n<td>0.5 50 errors per KLOC</td>\n</tr>\n<tr>\n<td>64K 512K</td>\n<td>2 70 errors per KLOC</td>\n</tr>\n<tr>\n<td> 512K or more </td>\n<td>4 100 errors per KLOC</td>\n</tr>\n</tbody>\n</table>\n<p>Sources: \"Program Quality and Programmer Productivity\" (Jones 1977), Estimating Software Costs (Jones 1998).</p>\n<p>Productivity is also affected by the project size, the bigger the project, the less productivity is to be expected by programmers.<br>\n<img src=\"images/timespentonconstruction.gif\">  </p>\n<p>Communication also doesn't scale linearly but mulltiplicatively, proportionally to the square of the number of people causing more time to be spent on\ncommunication and less on programming.</p>\n<p><img src=\"images/communication.gif\">  </p>\n<h2>Treating programmers as people</h2>\n<p>Good programmers tend to cluster, as do bad programmers,\n<em>A study proved there was a 3.4 to 1 effort expanded and a 3 to 1 program size difference. Another study, a 5-1 difference in program size and a 2.6-to-1 in time required. Another study.. 80 percent of contribution comes from 20 percent of contributors.a team in the 15th percentile required 3.5 time as much work month as a team in the 90th percentile.</em></p>\n<p><em>The implication for recruiting and hiring is clear. If you have to pay more to get to a top 10 percent programmer rather than a bottom 10 percent programmer, jump at the chance. You'll get an immediate payoff in the quality and productivity of the programmers your organization is able to retain because good programmers tend to cluster.</em></p>\n<h3>Physical Envrionment</h3>\n<p><em>In summary, if your workplace is a bottom-25 percent envrionment, you can realize about a 100 percent improvement in prdocutvirty by making it a top-25 percent environment. If your workplace is average, you can still realize a productivity improvement of 40 percent or more by making it a top-25 percent envrionment.</em></p>\n<h1>Software Craftsmanship</h1>\n<h2>Toolbox</h2>\n<p>A programmer's toolbox, using the right tool can make a problem trivial where as using the wrong tools can make it a nightmare. <em>It's useful to have a large toolbox, in which a multitude of tools can be found, but it is even more to know how and when to apply these tools.</em>.</p>\n<p>The software industry constantly develops new tools that reduce or eliminate some of the most tedious aspects of progrmaming. It is very important to stay up to date on tools in order to be able to do work efficiently.</p>\n<h2>Personal Character</h2>\n<p><em>The whole job of programming is building air castles - it's one of the most puerly mental activities you can do.</em></p>\n<p><em>Your employer can't force you to be a good programmer, a lot of times your employers isn't even in a position to judge whether you're good. If you want to be great, you're responsible for making yourself great , It's a matter of your personal character.</em></p>\n<p>Character is one of the most important thing a software developer can posses, it takes a special kind of person in order to spend 8 hours in front of a monitor trying to solve problems.</p>\n<p>Programming is one of the hardest mental task one can do, it is akin to building a sky castle in your head where any distraction will make the castle crumble.\nA mark of a good software developper is acknowledging the lack of mental capacity he has in order to comprehend the entirety of the source code human has for\nprogramming and trying to reduce the amount of information he needs at any single moment.</p>\n<p><em>The inwardness of programming makes personal character especially important. You know how difficult it is to put in eight concentrated hours in one day.You've probably had the experience of being burned out one day from concentrating too hard the day before or burned out one month after concentrating too hard the month before.</em></p>\n<h3>Intelligence and Humility</h3>\n<p><em>Nobody is smart enough to program computers (...). The way you focus your intelligence is more important than how much intelligence you have (...). The people who are the best at programming are the people who realize how small their brains are. They are humble. The more humble you are, the faster you'll improve.</em></p>\n<h3>Curiosity</h3>\n<p><em>Once you admit that your brain is too small to understand most programs and you realize that effective programming a search for ways to offset thhat fact, you begin a career-long search for ways to compensate. In the development of a superior programmer, curiosity about  technical subjects must be a priority. If you aren't curious enough to keep up with the changes, you might find yourself down at the old-programmers' home playing cards with T-Bone Rex and the Brontosaurus sisters.</em></p>\n<p><em>Programmers are so busy working they often don't have time to be curious about how they might do their job better.</em></p>\n<h3>Upgrading your awareness</h3>\n<p><strong>Build you awareness about of the development process.</strong> <em>The more aware you are of the development process, whether from reading or fromy our own observation about software development, the better position you're in to udnerstand changes and to move your group in the right direction.</em></p>\n<p><em>If your workload consists entirely of short-term assignements that don't develop your skills, be dissatisfied. A third of what you need to know will be out of date in three years. You're in too much to spend time working for management that doesn't have your interest in mind.</em></p>\n<p><strong>Experiment</strong>. <em>One effective way to learn programming is to experiment wtih programmingand the development process. If you don't know how a feature of your language works, write a short program to exercice the feature and see how it works. You're better off working with a short program to test a concept than you are writing a larger program with a feature you don't quite understand.</em></p>\n<p><strong>Read about problem solving</strong> <em>It was found in a study that human beings don't always discover clever problem-solving strategies themselves, even though the same strategies could readily be taught to the same people.</em></p>\n<p><strong>Analyse and plan before you act.</strong></p>\n<p><strong>Learn about succesful projects</strong> <em>One good way to learn is to study the work of great programmers. Jon Bentley thinks that you should be able to sit down with a glass of brandy and a good cigar and read a program the way you would a good novel. That might not be as far-fetched as it sounds. Most people wouln't want to use their recreational time to scrutinize a 500-pagesource listing, but manypeople would enjoy studying a high-level diesn and dipping into more detailed source listings for selected areas.</em></p>\n<p><strong>Read!</strong> </p>\n<p><em>Read the documentation or source code of things you use, you can develop a better understanding, more often than note a class you need has already been developped.</em></p>\n<p><strong>Read other books and periodicals</strong></p>\n<p><em>One book on software is more than most people in the software industry read each year. If you read even one good programming book every two months, roughly 35 pages a week, you'll soon have a firm grasp on the industry and distinguish yourself from nearly everyone around you.</em></p>\n<h3>Characteristics That Don't Matter as Much as You Might Think - Experience</h3>\n<p><em>People also put an absurd emphasis on the amount of experience programmers have. \"We want a programmer with five years of C programming experience\" is a silly statement, if a programmer hasn't learned C after a year or two, the next three year won't make much differrence. This kind of \"exeprience\" has little relationship to performance.</em></p>\n<p><em>In many fields, a professional who has a history of achivement can coast, relaxing and enoying the respect earned by a string soccesses. In software development, anyone who coast quickly becomes out of touch. To stay valuable, you have to stay current. For young hungry programmers, this is an advantage .Older programmers sometimes feel they've already earned their stripes and resent having to prove themsleves year after year.</em></p>\n<h3>Habits</h3>\n<p><em>Bill Gates sasys that any programmer who will ever be good is good in the first few years. After that, whether a programmer is good not, is cast in concrete. After you've been programming a long time, it's hard to suddenly start saying \"How do I make this loop fast?\" or \"How do I make this code more readable?\" These are habits that good programmers develop early.</em></p>\n<p><em>When you first learn something, learn it the right way. When you first do it, you're actively thinking about it and you still have an easy choice between doing it in a good way and doing it in a bad way. After you've done it a few times, you pay less attetnion to what you're doing and \"force of habit\" takes over. Make sure the habits that take over are the ones you want.</em></p>\n<h2>Pick your process</h2>\n<p><em>Always be thinking, \"Am I doing this in the right order? Would changing the order make a difference? \"Consciously follow a good process. Low level processes also matter.</em></p>\n<p><em>Software development is a creative exercise. If you don't understand the creative process, you're not getting the most out of the primary tool you use to create software-your brain. A bad process wastes your brain cycles. A good process leverages them to the maximum advantage.</em></p>\n<h2>Experimentation</h2>\n<p>// TODO FIX THIS\n<em>Electism has a close relative in experimenation. You need to experiment throughout the development process, but zealous inflexibility hobbles the impusle. To experiment effectively, you must be willing to change your beliefs based on the rseults fothe experiment. If you're not willing, experimentation is a grauitous waste of time.</em></p>\n<p><em>A blanket attempt to avoid mistakes is the biggest mistake of all.</em></p>","frontmatter":{"title":"Code Complete","backgroundColor":null,"tags":["programming"],"date":"December 13, 2020","image":{"childImageSharp":{"fluid":{"src":"/static/23ebe98fdac2439b940537496e2f8c8e/883ab/peace.jpg","srcSet":"/static/23ebe98fdac2439b940537496e2f8c8e/32ee9/peace.jpg 500w,\n/static/23ebe98fdac2439b940537496e2f8c8e/2f7e7/peace.jpg 1000w,\n/static/23ebe98fdac2439b940537496e2f8c8e/883ab/peace.jpg 2000w,\n/static/23ebe98fdac2439b940537496e2f8c8e/3d25e/peace.jpg 2048w","sizes":"(max-width: 2000px) 100vw, 2000px"}}}}}},"pageContext":{"slug":"/blog/2020-11-29-code-complete-16-years-later/","previous":{"fields":{"slug":"/blog/2020-06-11-freeeee/"},"frontmatter":{"title":"Free","image":{"id":"1f767cd9-0d35-50b3-9a54-c3626ebca18c"}}},"next":{"fields":{"slug":"/blog/2021-03-10-how-to-create-alias-property-in-your-csproj/"},"frontmatter":{"title":"How to Use Extern Alias to differentiate assemblies with the same namespace in C#","image":null}}}},"staticQueryHashes":["3868140423"]}