{"componentChunkName":"component---src-templates-blog-post-jsx","path":"/blog/2021-09-04-how-to-fix-object-cycle-detected-properly-automapper copy/","result":{"data":{"site":{"siteMetadata":{"title":"jean.arjean","author":"jean.arjean"}},"markdownRemark":{"id":"03481c03-ee42-5e35-99ba-951dab457fc4","html":"<p>This issue has already been pretty well discussed <a href=\"https://khalidabuhakmeh.com/ef-core-and-aspnet-core-cycle-issue-and-solution\">here</a>. However, I think this solution could be made easier to maintain at the cost of adding an additional dependency to your project.</p>\n<p>Given a project containing the following entities:</p>\n<deckgo-highlight-code csharp  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">// Product.cs\n    public class Product\n    {\n        public string Id { get; set; }\n\n        public string Name { get; set; }\n\n       \tpublic virtual Store Store { get; set; }\n\n        public string StoreId { get; set; }\n\n    }\n\n// Store.cs\n  \tpublic class Store\n    {\n        public string Id { get; set; }\n\n        public string Name { get; set; }\n\n        public IEnumerable&lt;Product&gt; Products { get; set; }\n    }</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code csharp  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">// StoreController.cs\n    [HttpGet(&quot;{storeId}&quot;)]\n    public async Task&lt;IActionResult&gt; GetStore([FromRoute] string storeId)\n    {\n        var result = await _dbContext.Set&lt;Store&gt;().Include(x =&gt; x.Prints).FirstAsync(x =&gt; x.Id == storeId);\n\n        return new OkObjectResult(result);\n    }</code>\n        </deckgo-highlight-code>\n<p>This would result in an exception being thrown while trying to serialize the object, \"System.Text.Json.JsonException: A possible object cycle was detected\" if the store has any product\nas there's an endless relationship cycle between a Store and a Product.</p>\n<p> We can solve this by mapping our Product and Store entities to Resource objects, using resource objects, we can dictate\nwhat the users of our API will see when they query it instead of having to adapt our Database Entity to work with our API.</p>\n<p> Our resources could look like this.</p>\n<deckgo-highlight-code csharp  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">// ProductResource.cs\n    public class ProductResource\n    {\n        public string Id { get; set; }\n\n        public string Name { get; set; }\n\n        public string StoreId { get; set; }\n    }\n\n// StoreResource.cs\n  \tpublic class StoreResource\n    {\n        public string Id { get; set; }\n\n        public string Name { get; set; }\n\n        public IEnumerable&lt;string&gt; ProductIds { get; set; }\n    }</code>\n        </deckgo-highlight-code>\n<p>And our controller would look like this</p>\n<deckgo-highlight-code csharp  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">// StoreController.cs\n    [HttpGet(&quot;{storeId}&quot;)]\n    public async Task&lt;IActionResult&gt; GetStore([FromRoute] string storeId)\n    {\n        var result = await _dbContext.Set&lt;Store&gt;.FindAsync(storeId);\n        var storeResource = new StoreResource{\n            Id = result.Id,\n            Name = result.Name,\n            Path = result.Path,\n            Prints =  result.Prints.Select(x =&gt; new PrintResource\n            {\n                Id = x.Id,\n                Name = x.Name,\n                StoreId = x.StoreId\n            })\n        };\n        return new OkObjectResult(storeResource);\n    }</code>\n        </deckgo-highlight-code>\n<p>The problem is solved and we no longer have the error we started with, however this isn't very portable, we'd have to copy and paste this\ncode in all our controllers that return a store which would be pretty messy, verbose and error prone. Furthermore, when we'd start adding\nadditional properties to our store, we'd have to think about every controller where this logic is in place and go change it manually.</p>\n<p>A simple solution is to maintain an extension class for our store which we can reuse anywhere in our codebase.</p>\n<deckgo-highlight-code csharp  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">// StoreExtension.cs\n    public static class StoreExtension\n    {\n        public static StoreResource ToResource(this Store store)\n        {\n            return new StoreResource{\n                Id = store.Id,\n                Name = store.Name,\n                Path = store.Path,\n                Prints =  store.Prints?.Select(x =&gt; new PrintResource\n                {\n                    Id = x.Id,\n                    Name = x.Name,\n                    StoreId = x.StoreId\n                })\n            };\n        }\n    }</code>\n        </deckgo-highlight-code>\n<p>Our controller then becomes a lot less verbose. </p>\n<deckgo-highlight-code csharp  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">// StoreController.cs\n    [HttpGet(&quot;{storeId}&quot;)]\n    public async Task&lt;IActionResult&gt; GetStore([FromRoute] string storeId)\n    {\n        var result = await _dbContext.Set&lt;Store&gt;.FindAsync(storeId);\n        var storeResource = result.ToResource();\n        return new OkObjectResult(storeResource);\n    }</code>\n        </deckgo-highlight-code>\n<p>This is better and our codebase is now much more maintainable because we centralized our mapping and there's no more copy and paste involved\nto map our Store objects to a StoreResource object. </p>\n<h1>Using AutoMapper</h1>\n<p>If our application has many entities, it can be beneficial to automate the mapping from Store to StoreResource. We can do this by\nusing the library AutoMapper.</p>\n<p>AutoMapper is a library that allows us to map an object from one object type to another. AutoMapper does this by trying to map properties\nwith the same name on the source object and the target object.</p>\n<p>We start by adding the following Nuget to our .csproj file</p>\n<deckgo-highlight-code xml  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">//NameOfProject.cs\n    &lt;ItemGroup&gt;\n        &lt;PackageReference Include=&quot;AutoMapper.Extensions.Microsoft.DependencyInjection&quot; Version=&quot;8.1.1&quot; /&gt;\n    &lt;/ItemGroup&gt;        </code>\n        </deckgo-highlight-code>\n<p>Then we add an AutoMapper Profile class to our project which defines the mapping </p>\n<deckgo-highlight-code csharp  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">// StoreProfile.cs\n    public class StoreProfile : AutoMapper.Profile\n    {\n        public StoreProfile()\n        {\n            CreateMap&lt;Print, PrintResource&gt;();\n            CreateMap&lt;Store, StoreResource&gt;();\n        }\n    }</code>\n        </deckgo-highlight-code>\n<p>Then in our Startup class, we need to add AutoMapper to our IoC container</p>\n<deckgo-highlight-code csharp  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">// Startup.cs\n    public void ConfigureServices(IServiceCollection services)\n    {\n        services.AddAutoMapper(typeof(StoreProfile));\n    }</code>\n        </deckgo-highlight-code>\n<p>Finally in our controller, we inject an IMapper instance and modify our Get Method for it to use AutoMapper.</p>\n<deckgo-highlight-code csharp  terminal=\"none\"  highlight-lines=\"\">\n          <code slot=\"code\">// StoreController.cs\n    private readonly StoreDbContext _dbContext;\n    private readonly IMapper _mapper;\n    \n    public StoreController(IMapper mapper, StoreDbContext dbContext)\n    {\n        _dbContext = dbContext;\n        _mapper = mapper;\n    }\n\n    [HttpGet(&quot;{storeId}&quot;)]\n    public async Task&lt;IActionResult&gt; GetStore([FromRoute] string storeId)\n    {\n        var result = await _dbContext.Set&lt;Store&gt;().Include(x =&gt; x.Prints).FirstAsync(x =&gt; x.Id == storeId);\n        var storeResource = _mapper.Map&lt;StoreResource&gt;(result);\n        return new OkObjectResult(storeResource);\n    }</code>\n        </deckgo-highlight-code>\n<p>There we have it, a different solution to the object cycle detected problem which I believe is very maintainable and easy\nto use.</p>\n<p>If you have further questions, feel free to ask them here: <a href=\"mailto:arguinjr@gmail.com?subject=Extern%20Alias%20CSharp\">arguinjr@gmail.com</a></p>","frontmatter":{"title":"How to Fix \"A possible object cycle was detected\" properly in your .Net project using AutoMapper","backgroundColor":"white","tags":["csharp","csproj"],"date":"September 05, 2021","image":null}}},"pageContext":{"slug":"/blog/2021-09-04-how-to-fix-object-cycle-detected-properly-automapper copy/","previous":{"fields":{"slug":"/blog/2021-09-04-how-to-fix-object-cycle-detected-properly-automapper/"},"frontmatter":{"title":"How to Fix \"A possible object cycle was detected\" properly in your .Net project using AutoMapper","image":null}},"next":null}},"staticQueryHashes":["3868140423"]}